# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12rY7bsKhe0kbFrs24nK0gPW4hxS8_RxX
"""

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf

# Set the date range starting from Nov 29, 2019
start_date = "2019-11-29"
end_date = "2025-04-08"  # Up to the current date

# Fetch stock data for AAPL, TSLA, and MSFT
stocks = ['AAPL', 'TSLA', 'MSFT']
data = yf.download(stocks, start=start_date, end=end_date)['Adj Close']

# Function to simulate a random walk based on stock price changes
def random_walk_simulation(price_series, steps):
    returns = price_series.pct_change().dropna()  # Daily returns
    random_steps = np.random.choice(returns, size=steps)  # Randomly sample returns
    random_walk = np.cumprod(1 + random_steps) * price_series.iloc[0]  # Cumulative product
    return random_walk

# Perform unit root test (Augmented Dickey-Fuller)
def unit_root_test(series, stock_name):
    result = adfuller(series.dropna())
    print(f'\nUnit Root Test (ADF) for {stock_name}:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:', {k: round(v, 4) for k, v in result[4].items()})
    if result[1] < 0.05:
        print(f"{stock_name} is stationary (reject null hypothesis)")
    else:
        print(f"{stock_name} has a unit root (non-stationary, fail to reject null)")

# Plotting function for stock prices and random walk
def plot_stock_and_random_walk(data, stock):
    plt.figure(figsize=(10, 6))
    plt.plot(data.index, data[stock], label=f'{stock} Actual Price', color='blue')
    rw = random_walk_simulation(data[stock], len(data[stock]))
    plt.plot(data.index, rw, label=f'{stock} Random Walk', color='orange', linestyle='--')
    plt.title(f'{stock} Stock Price vs Random Walk')
    plt.xlabel('Date')
    plt.ylabel('Adjusted Close Price (USD)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Plotting correlogram
def plot_correlogram(series, stock):
    plt.figure(figsize=(10, 6))
    plot_acf(series.dropna(), lags=40, title=f'Correlogram of {stock} Stock Price')
    plt.show()

# Analyze each stock
for stock in stocks:
    print(f"\n=== Analysis for {stock} ===")

    # 1. Plot stock price and random walk
    plot_stock_and_random_walk(data, stock)

    # 2. Unit root test
    unit_root_test(data[stock], stock)

    # 3. Correlogram
    plot_correlogram(data[stock], stock)

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf

# Set the date range starting from Nov 29, 2019
start_date = "2019-11-29"
end_date = "2025-04-08"  # Up to the current date

# Fetch stock data for AAPL, TSLA, and MSFT
stocks = ['AAPL', 'TSLA', 'MSFT']
print("Downloading stock data...")
data = yf.download(stocks, start=start_date, end=end_date)

# Check if data was retrieved successfully
if data.empty:
    raise ValueError("No data retrieved from yfinance. Check your internet connection or ticker symbols.")

# Debugging: Print the columns to see what's available
print("Available columns in data:", data.columns)

# Use 'Adj Close' if available, otherwise fallback to 'Close'
if 'Adj Close' in data.columns:
    price_data = data['Adj Close']
elif 'Close' in data.columns:
    price_data = data['Close']
    print("Warning: 'Adj Close' not found. Using 'Close' instead.")
else:
    raise KeyError("Neither 'Adj Close' nor 'Close' found in the data.")

# Function to simulate a random walk based on stock price changes
def random_walk_simulation(price_series, steps):
    returns = price_series.pct_change().dropna()  # Daily returns
    random_steps = np.random.choice(returns, size=steps)  # Randomly sample returns
    random_walk = np.cumprod(1 + random_steps) * price_series.iloc[0]  # Cumulative product
    return random_walk

# Perform unit root test (Augmented Dickey-Fuller)
def unit_root_test(series, stock_name):
    result = adfuller(series.dropna())
    print(f'\nUnit Root Test (ADF) for {stock_name}:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:', {k: round(v, 4) for k, v in result[4].items()})
    if result[1] < 0.05:
        print(f"{stock_name} is stationary (reject null hypothesis)")
    else:
        print(f"{stock_name} has a unit root (non-stationary, fail to reject null)")

# Plotting function for stock prices and random walk
def plot_stock_and_random_walk(data, stock):
    plt.figure(figsize=(10, 6))
    plt.plot(data.index, data[stock], label=f'{stock} Actual Price', color='blue')
    rw = random_walk_simulation(data[stock], len(data[stock]))
    plt.plot(data.index, rw, label=f'{stock} Random Walk', color='orange', linestyle='--')
    plt.title(f'{stock} Stock Price vs Random Walk')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Plotting correlogram
def plot_correlogram(series, stock):
    plt.figure(figsize=(10, 6))
    plot_acf(series.dropna(), lags=40, title=f'Correlogram of {stock} Stock Price')
    plt.show()

# Analyze each stock
for stock in stocks:
    print(f"\n=== Analysis for {stock} ===")

    # 1. Plot stock price and random walk
    plot_stock_and_random_walk(price_data, stock)

    # 2. Unit root test
    unit_root_test(price_data[stock], stock)

    # 3. Correlogram
    plot_correlogram(price_data[stock], stock)

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf

# Set the date range starting from Nov 29, 2019
start_date = "2019-11-29"
end_date = "2025-04-08"  # Up to the current date

# Fetch stock data for AAPL, TSLA, and MSFT
stocks = ['AAPL', 'TSLA', 'MSFT']
print("Downloading stock data...")
data = yf.download(stocks, start=start_date, end=end_date)

# Check if data was retrieved successfully
if data.empty:
    raise ValueError("No data retrieved from yfinance. Check your internet connection or ticker symbols.")

# Debugging: Print the columns to see what's available
print("Available columns in data:", data.columns)

# Use 'Adj Close' if available, otherwise fallback to 'Close'
if 'Adj Close' in data.columns:
    price_data = data['Adj Close']
elif 'Close' in data.columns:
    price_data = data['Close']
    print("Warning: 'Adj Close' not found. Using 'Close' instead.")
else:
    raise KeyError("Neither 'Adj Close' nor 'Close' found in the data.")

# Function to simulate a random walk based on stock price changes
def random_walk_simulation(price_series, steps):
    returns = price_series.pct_change().dropna()  # Daily returns
    random_steps = np.random.choice(returns, size=steps)  # Randomly sample returns
    random_walk = np.cumprod(1 + random_steps) * price_series.iloc[0]  # Cumulative product
    return random_walk

# Perform stationarity test (Augmented Dickey-Fuller) and interpret
def stationarity_test(series, stock_name):
    result = adfuller(series.dropna())
    print(f'\nStationarity Test (ADF) for {stock_name}:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:', {k: round(v, 4) for k, v in result[4].items()})
    if result[1] < 0.05:
        print(f"Result: {stock_name} is STATIONARY (p-value < 0.05, reject null hypothesis of unit root).")
        print("Interpretation: The series does not have a unit root and does not follow a pure random walk.")
    else:
        print(f"Result: {stock_name} is NON-STATIONARY (p-value >= 0.05, fail to reject null hypothesis of unit root).")
        print("Interpretation: The series has a unit root, suggesting it may follow a random walk with drift or trend.")

# Plotting function for stock prices and random walk
def plot_stock_and_random_walk(data, stock):
    plt.figure(figsize=(10, 6))
    plt.plot(data.index, data[stock], label=f'{stock} Actual Price', color='blue')
    rw = random_walk_simulation(data[stock], len(data[stock]))
    plt.plot(data.index, rw, label=f'{stock} Random Walk', color='orange', linestyle='--')
    plt.title(f'{stock} Stock Price vs Random Walk')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Plotting correlogram
def plot_correlogram(series, stock):
    plt.figure(figsize=(10, 6))
    plot_acf(series.dropna(), lags=40, title=f'Correlogram of {stock} Stock Price')
    plt.show()

# Analyze each stock
for stock in stocks:
    print(f"\n=== Analysis for {stock} ===")

    # 1. Plot stock price and random walk
    plot_stock_and_random_walk(price_data, stock)

    # 2. Stationarity test (replacing unit root test)
    stationarity_test(price_data[stock], stock)

    # 3. Correlogram
    plot_correlogram(price_data[stock], stock)